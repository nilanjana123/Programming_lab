import random , math, time
from threading import Event, Thread , Lock
from time import sleep

# A list for storing the events generated by EG thread so that EC thread can come and consume them 
q = []

# used lock variables to ensure atomacity
lock1 = Lock()
lock2 = Lock()

# complete variable is used to indicate if the EG thread completed its thread generation or not 
complete = Event()
complete.set()
start_time = math.floor(time.perf_counter())                  
            
# generateEvent is the target of EG thread , it generates 10 thraed.
def generateEvent():
    # count variable is a private variable to generateEvent method , it represents no of events to be generated 
    count = 10
    while count>0: 
        # new event will be generated only if there is no thread to consume or q has no element 
        if len(q) == 0:
            # acquire lock 
            lock1.acquire()
            
            # γ represents the time to wait before generating a thread . 
            γ = math.floor(random.uniform(1,5))
            current_time = math.floor(time.perf_counter()) - start_time              # Current time 


            # prints the time when event is scheduled . its current time + γ . 
            print('Time ' +format(current_time)+'s : '+'Event scheduled at ' + format(current_time+γ) +'s'+'\n',end='')
            # sleep for γ time 
            sleep(γ)

            # create new event evnt 
            evnt = Event()
            # decrement count 
            count-=1
            # append evnt to q so that EC can consume it 
            q.append(evnt)
            # set the event 
            evnt.set()
            # release lock as event generation completes 
            lock1.release()
    # clear complete event when all thread generation is done 
    complete.clear()

# consumeEvent cis target of EC thread . it comsumes the thread generated by EG thraed . 
def consumeEvent():
    # while all events are not generated or q is not empty , consume events .
    while complete.is_set() or len(q)>0:
        # if q has element , consume it 
        if len(q) > 0:
            # acquire lock to ensure atomicity 
            lock2.acquire()
            # print the time when event occured
            current_time = math.floor(time.perf_counter()) - start_time              # Current time  
            print('Time ' +format(current_time)+'s : '+'Event occured  \n',end='')
            # wait for µ sec before consuming / processing thread .
            µ = math.floor(random.uniform(1,5))
            # wait by sleeping for µ sec 
            sleep(µ)
            # print the time when the event has processed 
            current_time = math.floor(time.perf_counter()) - start_time              # Current time 
            print('Time ' +format(current_time)+'s : '+'Event Processed')
            # after the event being processed , remove the event from q .
            e = q.pop()
            # clear the event 
            e.clear()
            # release the lock 
            lock2.release()
    # after all threads are consumed , print the appropriate message 
    print('All events have been processed')

# Create EG thread to generate new event 
EG = Thread(target= generateEvent)
# Create EC thread to consume generated event 
EC = Thread(target= consumeEvent)

# start EG and EC thread 
EG.start()
EC.start()
